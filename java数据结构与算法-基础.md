---
title: java数据结构与算法--基础
categories:
  - 数据结构与算法
abbrlink: f2c524f6
date: 2020-04-10 13:07:23
---

#### 数据结构的基本概念

- 数据
- 数据项
- 数据元素
- 数据对象
- 数据结构

<!--more-->

##### 数据

数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。

##### 数据项

数据项具有原子性，是不可分割的<font color="red">最小数据单位</font>。

##### 数据元素

数据元素是数据的基本单位，是数据集合的个体，通常由若干个数据项组成，在计算机程序中通常作为一个整体来进行处理。

##### 数据对象

数据对象是性质相同的数据元素的集合，是数据的子集。

##### 数据结构

数据结构是指相互之间存在一种或多种的数据元素的集合。

- 逻辑结构：数据结构的逻辑层面

  - 线性结构
    - 线性表
    - 栈
    - 队列
    - 串及数组
  - 非线性结构
    - 树形结构
    - 图形结构

- 数据的存储结构：存在于计算机世界的物理层面

  - 顺序存储
  - 链式存储
  - 索引存储
  - 散列存储

- 数据结构的运算：检索、排序、插入、删除、修改……

#### 数据结构类型

- <font color="red">线性表</font>
- 栈、堆
- 队列
- (字符)串
- 数组
- 广义表
- 树
- <font color="red">二叉树</font>
- 图

##### 数据的逻辑结构

数据的逻辑结构指数据元素之间的逻辑关系（和实现无关）。

###### 线性结构与非线性结构

- 线性结构：有且只有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个后继
  - 集合中必存在唯一的一个"第一个元素"
  - 集合中必存在唯一的一个"最后的元素"
  - 除最后元素之外，其他数据元素均有唯一的"后继"
  - 除第一元素之外，其他元素均有唯一的"前驱"
- 非线性结构：一个结点元素可能对应多个直接前驱和多个直接后继
  - 树状（二叉树...）
  - 图（网...）

###### 集合结构、线性结构、树状结构、网状结构

- 集合结构(Set)
  - 确定性：集合中的元素必须是确定的;
  - 唯一性：结合中的元素互不相同；
  - 无序性：集合中的元素没有先后之分。
- 线性结构：数据元素之间存在着"一对一"的线性关系的数据结构
- 树状结构：除了一个数据元素以外每个数据元素有且仅有一个直接前驱元素，但是可以有多个直接后续元素（一对多）
- 网状结构：每个数据元素可以有多个直接前驱元素，也可以有多个直接后续元素（多对多）

##### 数据的存储结构

数据的存储结构主要包括数据元素本身的存储以及数据元素之间关系表示，是数据的逻辑结构在计算机的表示。

###### 顺序储存结构

把逻辑上相邻的结存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现

- 优点：节省存储空间（分配数据的存储单元全用存放结点的数据，不考虑C/C++语言中数组需指定大小的需求），结点之间的关系没有占用额外的存储空间，可实现对结点的随机存取（一个结点对应一个序号）
- 缺点：插入和删除操作需要移动元素，效率较低

###### 链式存储结构

数据元素的存储结构是不连续的存储空间，每个存储结点对应一个需要存储的数据元素，每个结点是由数据域和指针组成，元素之间的逻辑关系通过存储结点之间的链接关系反映。

- 比顺序存储结构的存储密度小（每个结点都由数据域和指针域组成，所以相同空间内假设全存满时顺序比链式存储更多）
- 逻辑上相邻的结点物理上不必相邻
- 插入、删除灵活（不必移动结点，之哟啊改变结点中的指针）
- 查找结点时链式存储结构要比顺序存储慢

- 索引结构：除建立存储结点信息外，还建立附加的索引表来标识结点的地址
- 散列结构（hash表）：根据结点的关键字直接计算出该结点的存储地址

##### 总结



![数据结构总结.png](https://i.loli.net/2020/03/27/DbWwQTzojYs6Sn4.png)

#### 算法的基本概念

算法是指令的集合，是为解决特定问题而规定的一系列操作。它是明确定义的可计算过程，以一个数据集合作为输入，并产生一个数据集合作为输出。

- 输入：一个算法应以待解决的问题的信息作为输入。
- 输出：输入对应指令集后得到的信息。
- 可行性：算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时间内完成。
- 有穷性：算法执行的指令个数是有限的，每个指令又是在有限时间内完成的，因此整个算法也是在有限时间内可以结束的。
- 确定性：算法对于特定的合法输入，其对应输出是唯一的，即当算法从一个特定输入开始，多次执行同一指令集结果总是相同的。

算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间资源，复杂度分为时间复杂度和空间复杂度。

#### 算法时间复杂度

时间复杂度是执行算法所需要的计算工作量。

##### 时间频度

一个算法执行所耗费的时间(需在机器上运行才能测出)。

一个算法花费的时间与算法中语句执行次数成正比例，哪个算法中语句执行次数多，花费时间就多。

一个算法中的语句执行次数为语句频度或时间频度，表示为T(n),n表示问题的规模。

##### 时间复杂度

一般情况下，算法中基本操作重复执行的次数是问题规模的某个函数，用T(n)表示。

若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数时，则称f(n)时T(n)的同数量级函数。记作T(n)=O(f(n))为渐进时间复杂度，简称时间复杂度。T(n)=O(f(n))

**时间复杂度是时间频度去掉低阶项和首项常数。**

时间频度与时间复杂度是不相同的，时间频度不同但时间复杂度可能相同。

eg：某两个算法的时间频度分别是

- T(n)<sub>1</sub>=100 n<sup>2</sup>+100	

- T(n)<sub>2</sub>=10000 n<sup>2</sup>+10 n+6

其时间复杂度均为O(n<sup>2</sup> )。

###### 最坏时间复杂度与平均时间复杂度

- 最坏时间复杂度：最坏情况下的时间复杂度(一般情况下时间复杂度都是指最坏时间复杂度)。
- 平均时间复杂度：指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。
  - 难计算
  - 有很多算法的平均情况和最差情况的复杂度是一样的

*O符号：算法时间复杂度的上界(最坏情况 <=)*

*Ω符号：算法时间复杂度的下界(最好情况 >=)*

*Θ符号：算法时间复杂度的精确阶(最好和最坏是同一个阶 =)*

###### 时间复杂度计算

1. 找出算法中的基本语句：算法中执行次数最多的那条语句，通常是最内层循环的循环体。
2. 计算基本语句的执行次数的数量级：**只需计算基本语句执行次数的数量级**(可以忽略所有低次幂和最高次幂的系数)。
3. 用大O记号表示算法的时间性能：将基本语句执行次数的数量级放入大O记号中。

```java
int count=0;				// T(n)=O(1)

int count=0;
...						    // T(n)=O(1)
    
int count=0,n=8;
for(int i=0; i<n;i++)
    count++;				// T(n)=O(n)

int count=0,n=8;
for(int i=1; i<=n;i*=2)
    count++;				// T(n)=O(log2 n)

int count = 0, n = 8;
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
        count++;            // T(n)=O(n^2)

int count = 0, n = 8;
for (int i = 1; i <= n; i *= 2)
    for (int j = 0; j < n; j++)
        count++;            // T(n)=O(nlog2 n)
```

###### 常用时间复杂度级别

|  算法阶数  |     算法时间复杂度      |
| :--------: | :---------------------: |
|   常数阶   |          O(1)           |
|   对数阶   | O(log <sub>2</sub> n )  |
|   线性阶   |          O(n)           |
| 线性对数阶 | O(n log <sub>2</sub> n) |
|   平方阶   |    O(n<sup>2</sup>)     |
|   立方阶   |    O(n<sup>3</sup>)     |
|  k次方阶   |    O(n<sup>k</sup>)     |
|   指数阶   |    O(2<sup>n</sup>)     |
|   阶乘阶   |          O(n!)          |

**时间复杂度越高，执行效率越低**

#### 算法空间复杂度

空间复杂度是执行这个算法所需要的内存空间。

##### 空间复杂度

算法的存储容量包括：

- 程序本身所占空间
- 输入数据所占空间
- 辅助变量所占空间

输入数据所占空间只取决于问题本身，和算法无关，只需要分析除输入和程序之外的*辅助变量*所占额外空间。

空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的度量，一般也作为问题规模n的函数，以数量级形式给出，S(n)=O(g(n))。

###### 空间复杂度分析一

```java
int fun(int n) {
    int i, j, k, s;
    s = 0;
    for (i = 0; i < n; i++)
        for (j = 0; j <= i; j++)
            for (k = 0; k <= j; k++)
                s++;
    return s;
}
```

算法中临时变量的个数与问题规模n无关，因此空间复杂度均为*S(n)=O(1)*。

###### 空间复杂度分析二

```java
//n为数组a的元素个数
void fun(int a[], int n, int k) {
    int i;
    if (k == n - 1)
        for (i = 0; i < n; i++)
            System.out.print(a[i]);
    else {
        for (i = k; i < n; i++)
            a[i] = a[i] + i * i;
        fun(a, n, k + 1);
    }
}
```

递归算法，每次调用本身都要分配空间，fun(a,n,0)的空间复杂度为O(n)。

###### 注意

1. 空间复杂度相比时间复杂度分析要少。
2. 对于**递归算法**来说，代码一般都比较简短，算法本身所占用的存储空间较少，但运行时需要占用较多的临时工作单元；若改写成**非递归算法**，代码可能会较长，算法本身占用的存储空间较多，但运行时占用较少的临时工作单元。